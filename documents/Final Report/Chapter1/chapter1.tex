\chapter{Background \& Objectives}

Games are interesting projects to take on; they have a history of being difficult to make and pushing technology to its limits. There are a great many systems and features that can be included in them---AI, physics, graphics, audio, UI, multiplayer and more---and a great many ways to implement each, from simple to very complicated depending on the needs of the project.

Games also have a history of aiming for too many of these features in too little time. In most cases, every one of the features thought up would enhance the final product in some way, from a significant improvement that changes the way the game is played to a minor enhancement that makes things just a little more pleasant for the user. Many of these features may be considered mandatory for the game to be worth making at all. For example, a single-player chess game would probably not be very good if there were no AI to play against.

It is not just players who require features, however; developers of games need tools to implement the game design and a good engine to hang the design off of. A lot of game projects build custom tools that let developers and designers implement things quickly. Many game engines even provide methods for scripting and modding them after their release to players.

It is clear that, given the sheer enormity of the possible things that can be put into any one game, there is not enough time in this project to implement even half of them without a great deal of previous experience and skill. Every one of the major systems mentioned can be extremely complicated, requiring a lot of research, time and effort to make them work.

This chapter will discuss what the project is, why it was worth taking on and how a minimal system was devised that would satisfy enough of the game design requirements to be playable but also be implementable in the time given.

\section{Background}

\subsection{The Project}
Before discussing the decisions made about what was doable and why it was interesting, it's useful to know what the project actually is.

The name of the project---\textit{Browser-based Online Multiplayer Roleplaying Game}---gives a relatively good hint of the nature of the game. ``Browser-based'' and ``multiplayer'' are fairly self-evident in meaning: multiple people play together in a game hosted in the browser. ``Roleplaying game'' is more ambiguous. In this case, it refers to a game in the style of the classic tabletop roleplaying game \textit{Dungeons \& Dragons.}

In the context of the project that meant the following things: Firstly, there needed to be two types of players---regular players and a Game Master. A regular player plays the game as a character inhabiting the world they happen to be in. For example, they may be a dwarf in a fantasy kingdom, or a space marine on a futuristic space station.

The Game Master is a player responsible for building the world, telling the story and controlling characters that aren't controlled by the other players (known as Non-Player Characters or NPCs). Traditionally, the Game Master would also be responsible for enforcing the rules of the world. However, in this project the game was to be responsible for that instead, with the Game Master given the option of overriding or changing the rules if he or she wished to do so.

Combat is the most obvious area where the game enforcing the rules comes into effect. Combat is turn-based, with players put onto a grid and given limits on the distance they can move and number of actions they can perform in each turn. When they attempt to do something---such as attack another character or creature or escape from a trap---they have to roll dice, the result of which decides whether they were successful or not, and how well they succeeded or failed. As an example, a player failing to attack a creature with their sword could simply miss, or they could throw the sword away accidentally, depending on the result of the dice roll.

In the above scenario the dice rolls would be simulated by the game, rather than physical dice being used by the players. The game will also decide whether or not an action was valid in the first place. A player hoping to attack a creature with their sword would be unable to do so if the creature was too far away from them.

The design also called for interactions outside of combat. For instance, a player might be faced with a locked door. To get through a player could attempt to use a key they found or, alternatively, they could attempt to bash the door open with an item, such as an axe, or even their bare hands.

There are a few specific implementation details as well. Apart from the game being played via a browser, there needed to be graphics and those graphics needed to be \textsc{2d} isometric tiles. Further, the server was to be written in Python with the goal of gaining experience in the language.

With this overview of the game---a full account of the original game design can be found in Appendix \ref{appendix:designspec}---it is now important to answer why the project was worth doing.

\subsection{Why Make The Game?}
The first answer to this is that games are interesting in general. Most obviously, the final product of a game is (hopefully) something fun to play with appeal to a wide range of people. More relevant to the context of a project, however, is that games are interesting from a software perspective.

Games are made up of a lot of different parts, each one potentially being difficult to implement by itself. In this game, the most challenging individual parts are graphics and multiplayer. More important than just the individual parts, however, is making sure they integrate properly. In most cases the game needs to share data between these different pieces---game logic needs to know what an object is doing so it can perform game functions on it; the renderer needs to know what the object is doing so that it can be drawn to the screen correctly; the networking part needs to know what the object is doing so that it can forward on any relevant information to the server.

The game also offers a lot of extendibility. Given more time, more features can be added. Each feature, and fitting it together, offers a lot of potential for learning as well. For example, an extra feature could be AI, which is an interesting area in itself that offers a lot of opportunity to learn something new.

\subsection{Research}
With the previous questions answered some research needed to be done in order to gain an understanding of what was plausible in the time allowed for the project.

The first research step performed was to find information on games written in JavaScipt for the browser. The first thing to come up here was Mozilla's \textit{BrowserQuest}\cite{citeulike:13139186, citeulike:13139189}, a multiplayer role-playing game created in 2012 to show off the capabilities of modern browsers. This initially looked like a good find because it is open source \cite{citeulike:13139194}. However, it unfortunately proved to be fairly useless as the source code is large and, without technical documentation or a previous knowledge of game design, it is difficult to comprehend.

Moving on from that, another game was found called \textit{Roll20}\cite{citeulike:13141206}. This was an interesting find, showing that it was plausible to create the game in the first place but also that the game type has some audience. However, there are key differences between \textit{Roll20} and this project: namely, \textit{Roll20} is a game engine, supporting whatever game rules you care to enter into it; this project is an actual game. Beyond this there was little to gain except ideas for more extra features, none of which would be realistic to include in the project time frame.

Attempts were made to find books, tutorials and guides covering the creation of \textsc{html5} browser games. This proved to be harder than expected, primarily because most information on browser games is related to creating them in Adobe Flash with the ActionScript language. The materials that do exist for \textsc{html5} games are generally lacking. The best resources found---within budget, at least---consisted of two books\cite{citeulike:13000145, citeulike:13000170}, which proved to be either too long to read in their entirety to get the useful information, or too simplistic in game design model to be used as reference.

There were some online resources which proved somewhat useful. Initial development in the project was started by following a tutorial\cite{citeulike:13139212} that allowed initial understanding of how \textsc{html5} games are hooked into the browser and the basics of creating tile-maps (which will be discussed in more detail in Chapter 3). The code was all replaced but it was a useful start.

Another online resource which proved to be very useful was a tutorial on how to render isometric tiles in games in a simple way\cite{citeulike:13139216}. This tutorial was referenced heavily in early development to get the renderer up and running.

Finally, an online book detailing common game design patterns\cite{citeulike:13049596}---as well as how to use some traditional design patterns in games---proved to be extremely useful for creating the overall structure of the game engine.


\section{Analysis}
With the knowledge that the scope of games can expand to encompass a ridiculous area, and that everything within that scope is likely to be time consuming to implement, it is important to define what features are absolutely mandatory for the game to be worth making, and figure out how long it might take to implement them.

\subsection{Necessary Features}
The first of the necessary features is graphics. Graphics are the player's view into the world, letting them see the state of the game and figure out what their input needs to be. Without this view the only way to see into the world would be to debug the code as it was playing, which is not a very efficient way to play a game and the constant pausing would also break the game's timing, which is vital for games to operate correctly, particularly in a multiplayer setting. Of course, it is reasonable to operate a game with a textual interface. However, the game design specified that graphics be implemented and that those graphics be isometric tiles.

The second of the necessary features was multiplayer. All interactions in the game happen between players, be they regular players or the Game Master. Without any way for them to interact the game is relatively pointless to play---all you'd get as a player is being able to walk around a map with your character.

Multiplayer implies a few things. The first is that there needs to be a way of clients communicating with some remote version of the game. This could, in theory, be a peer to peer connection. However, there are problems with this. The first is that peer to peer is not such an easy thing to support technologically with a browser, as the web operates on a client-server model.

The second problem with peer to peer is that there is no trustworthy version of the game. All the players need to have a view into the same world and the underlying data needs to be consistent between them or problems would occur. There is nothing to stop any one of the players from modifying their client to perform actions they shouldn't be able to do, and it being run in a browser using JavaScript makes this even more of an issue as all browsers come with easy access to JavaScript debuggers. A single client could be made the authoritative version (with the Game Master being the most logical choice here). However, if that client is tampered with it would affect the game for everyone.

A server solves both of the issues that peer to peer represents. It is, of course, more natural for a browser to operated in a client-server manner. A server is also far more trustworthy than any individual client, and can be used as an authoritative base for the game so that, even if a player tampers with their client, the other players won't be affected.

The disadvantage to a server is that it requires resources and time to host and keep running. The more people who decide to play the game, the more server power is required. If the servers went down, no one would be able to play at all.

These two things represent technical requirements as much as game design requirements. The existence of both requires consideration in designing the structure of the game code. However, there are some other features required which could be considered purely game design issues.

The first of these is combat. In this case, combat is what makes the game a game. Without it players really only get to walk around a world together and look at how pretty it may or may not be, depending on the quality of the graphics used.

% Taking into account the problem and what you learned from the background work, what was your analysis of the problem? How did your analysis help to decompose the problem into the main tasks that you would undertake? Were there alternative approaches? Why did you choose one approach compared to the alternatives?

% There should be a clear statement of the objectives of the work, which you will evaluate at the end of the work.

% In most cases, the agreed objectives or requirements will be the result of a compromise between what would ideally have been produced and what was felt to be possible in the time available. A discussion of the process of arriving at the final list is usually appropriate.


\section{Process}
% You need to describe briefly the life cycle model or research method that you used. You do not need to write about all of the different process models that you are aware of. Focus on the process model that you have used. It is possible that you needed to adapt an existing process model to suit your project; clearly identify what you used and how you adapted it for your needs.

