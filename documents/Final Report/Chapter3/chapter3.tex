\chapter{Implementation}INTRODUCTION GOES HERE\section{Renderer}The graphics renderer was the first piece of the game engine worked on. Having the graphics to provide a view into the game world was important in order to easily see whether things were behaving as expected and proved extremely useful in detecting problems with other parts of the game later on.This section will go over firstly what isometric projection is and then the ways that graphics are actually drawn to the screen. Finally, the difficulties that the renderer caused during implementation will be discussed.\subsection{Isometric Tiles}\subsubsection{What Is Isometric?}When talking about isometric projection in the videogame world it is important to know that it is not truly isometric. True isometric is an ``axonometric projection in which the three coordinate axes appear equally foreshortened and the angles between any two of them are 120 degrees'' \todo{reference}. What the gaming world calls `isometric' is in fact \textit{dimetric} projection \todo{reference}---a projection where two axes are the same but the third is not.The reasons for doing this are essentially one of aesthetics when drawing objects at a very low resolution with visible pixels. At these very coarse resolutions, true isometric projection creates an aesthetically displeasing line. However, by changing to a dimetric projection, where the line grows twice as fast horizontally as it does vertically, the line becomes much more consistent and visually appealing. \todo{figure}\subsubsection{Cartesian To Isometric}The term ``\textsc{2d} isometric tile'' used in this report is a little ambiguous. The game world itself is represented by simple \textsc{2d} Cartesian coordinates that map to a grid of tiles. Isometric space, however, is \textsc{3d}. The term used here refers to the type of graphic used to represent the tiles in isometric space, rather than the isometric space itself. These graphics are simple \textsc{2d} images, drawn in such a way as to make them look \textsc{3d}. \todo{figure showing cartesian and isometric}Of course, this means that a conversion has to be made between the two coordinate systems in order for the renderer to be able to display things in their proper place. As an example, figure \todo{figure} shows what the game world looks like if it is rendered without this coordinate conversion---clearly very wrong.In order for the renderer to show things correctly in the isometric space there needs to be a way of converting between the game world's Cartesian coordinates and the renderer's isometric coordinates. Luckily, this is incredibly simple:\noindent\begin{minipage}{\linewidth}\begin{lstlisting}[style=js, caption={JavaScript implementation of a function to turn Cartesian coordinates into game isometric coordinates. Original algorithm from \cite{citeulike:13155325}.}, label=cartesian_to_isometric]function cartesianToIsometric(cartesian_x, cartesian_y){	var isometric = {};    isometric.x = cartesian_x - cartesian_y;    isometric.y = (cartesian_x + cartesian_y) / 2;    return isometric;}\end{lstlisting}\end{minipage}Now when the renderer draws the game to the \textsc{html5} canvas, it can first call the \texttt{cartesianToIsometric} function, letting it place the tile graphics in the correct place as seen in figure \todo{figure}.\subsection{Rendering}After the renderer has converted between Cartesian and isometric spaces it needs to be able to draw things to the canvas. The actual drawing of a game tile to the canvas is straightforward, simply requiring a call to the canvas's \texttt{drawImage()} function and supplying it the image you wish to draw and the canvas coordinates for where you wish it to be drawn.The difficult part comes before that. Firstly, you need to be able to work out what the canvas coordinates are. The conversion between isometric coordinates and the canvas coordinates works as follows:\noindent\begin{minipage}{\linewidth}\begin{lstlisting}[style=js, caption={Conversion between isometric coordinates and canvas coordinates.}, label=isometric_to_canvas]canvas_x = isoCoords.x * (TILE_WIDTH / 2);canvas_y = isoCoords.y * (TILE_HEIGHT / 2) - (image_height - (TILE_HEIGHT / 2));\end{lstlisting}\end{minipage}A few things should be explained about this. Firstly, \texttt{TILE\_WIDTH} and \texttt{TILE\_HEIGHT} refer to the set size of a single tile and are used to work out the tile's positioning in the world. The \texttt{image\_height} value refers to how tall in pixels an image is. Theoretically an image can have any size and isn't limited to how large a tile is. However, in practical terms, an image can only be arbitrarily tall; width needs to be kept within the tile limits or there will be problems with depth sorting, for reasons seen in section \ref{entity_rendering}.\todo{a figure showing the difference between a tile and the image representing it}Also worth noting is that there are separate rendering functions used for the terrain and the entities. The terrain has no height value, but even if it did it is rendered in such a way as to make it irrelevant, so the drawing of terrain tiles excludes the \texttt{image\_height} part of the calculation.Once you have the coordinates you then need to get the tile graphic to use as the image being rendered. Getting the image itself is a very simple task, but getting the order in which to draw them right is more difficult.The \textsc{html5} canvas is a very simple element and it has no ability to specify the relative depth of things being drawn to it; whatever is drawn first will be occluded by what comes afterwards if they overlap. This overlapping is often not a problem when drawing simple \textsc{2d} tiles with a top-down or side-on perspective. However, because the isometric perspective is \textsc{3d} the issue of depth becomes an important one.\todo{Figure of what it looks like when depth sorting is broken}There are two methods for solving this used in the renderer: a simple painter's algorithm and a depth sorting algorithm. The first is used for the terrain and the second for entities.\subsubsection{Terrain Rendering}The terrain is very simple to render as far as isometric projection goes. Terrain images are the same size as the tiles, which means that as long as they are drawn in order the images will never overlap.The method for achieving this ordering is known as a painter's algorithm\footnote{The painter's algorithm is so called because of a common painting technique whereby distant parts are painted before closer parts that might cover them.} and is very simple. Firstly, all the terrain is stored in a pre-sorted, two dimensional array. Columns are labelled \texttt{y} and rows are labelled \texttt{x}. Images are drawn by looping through each row in each column and drawing them one by one, rendering the images from back to front, row by row.\todo{Diagram showing how the painter's algorithm works}This is a very efficient and cheap way to render the images to the screen, and works perfectly for the terrain. Even if the terrain were to be made no longer flat, as long as it never broke out of the tile grid there would be no need to change how it is rendered.\subsubsection{Entity Rendering}\label{entity_rendering}Unfortunately, entities are less easy to deal with. At least some entities can move around---crossing tile boundaries when they do so---which means they cannot be stored in the same grid that makes up the tiles themselves. Because of this, some other method has to be devised in order to make sure that they are drawn to the screen in the right order.% The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?% It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant?% You can conclude this section by reviewing the end of the implementation stage against the planned requirements.